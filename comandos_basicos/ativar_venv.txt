Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

.\venv\Scripts\Activate.ps1
python -m venv venv

pip freeze > requirements.txt

pip install -r requirements.txt


pip install pipreqs
pipreqs . --force

Criar apenas o venv correspondente ao computador

PC FER
python -m venv venv_fer

PC OZO
python -m venv venv_ozo

PC LEO
python -m venv venv_leo

PC AND
python -m venv venv_and

PC PUB
python -m venv venv_pub

3) Ativar o venv

Ativar somente o venv daquele PC

FER
.\venv_fer\Scripts\Activate.ps1

OZO
.\venv_ozo\Scripts\Activate.ps1

LEO
.\venv_leo\Scripts\Activate.ps1

AND
.\venv_and\Scripts\Activate.ps1

PUB
.\venv_pub\Scripts\Activate.ps1


Prompt esperado:

(venv_fer) PS C:\...

4) Instalar dependÃªncias do projeto
pip install -r requirements.txt

5) Fixar o interpretador no VS Code (1Âª vez)

Ctrl + Shift + P

Python: Select Interpreter

Escolher:

.\venv_fer\Scripts\python.exe


(ou o correspondente ao PC)

***************
âœ… Formas CORRETAS de resolver
OPÃ‡ÃƒO 1 â€” Um venv por mÃ¡quina (RECOMENDADA)

Crie um venv com nome diferente por PC:

meu_projeto/
 â”œâ”€ src/
 â”œâ”€ requirements.txt
 â”œâ”€ venv_pc_notebook/
 â”œâ”€ venv_pc_desktop/
 â””â”€ .vscode/


No PC notebook:

python -m venv venv_pc_notebook


No PC desktop:

python -m venv venv_pc_desktop


Cada VS Code seleciona o seu interpreter local.

âœ”ï¸ Sem conflito
âœ”ï¸ CÃ³digo compartilhado
âœ”ï¸ Ambiente isolado
âœ”ï¸ EscalÃ¡vel



***
Pergunta 2

Posso mudar o nome do venv depois que ele foi criado?

âœ… Resposta curta

Sim, pode renomear a pasta do venv.
Isso funciona, com alguns cuidados.

O que acontece ao renomear

O Python nÃ£o depende do nome da pasta, apenas dos caminhos internos.

Exemplo:

venv/  â†’  venv_pc_notebook/

O que vocÃª PRECISA fazer depois

Selecionar novamente o interpreter no VS Code

Ctrl + Shift + P â†’ Python: Select Interpreter


(Se existir) Atualizar .vscode/settings.json

{
  "python.defaultInterpreterPath": "venv_pc_notebook\\Scripts\\python.exe"
}


Reativar:

.\venv_pc_notebook\Scripts\Activate.ps1

O que NÃƒO quebra ao renomear

pacotes instalados âœ”ï¸

pip âœ”ï¸

scripts âœ”ï¸

**********************************







************************************************************************
***************************************************************************



PASSO A PASSO â€” SAVE POINT OFICIAL
1ï¸âƒ£ Garanta que tudo estÃ¡ limpo

No terminal do VS Code:

git status


VocÃª deve ver:

nothing to commit, working tree clean


Se nÃ£o estiver limpo:

git add .
git commit -m "WIP: ajustes locais antes de save point"

2ï¸âƒ£ Crie o commit de â€œversÃ£o estÃ¡velâ€

Esse commit representa uma versÃ£o funcional conhecida.

git commit -m "STABLE: monitor funcional (vento/rajada corretos no HTML)"


ğŸ“Œ Dica:

Sempre comece com STABLE: ou BASELINE:

A mensagem deve dizer por que essa versÃ£o Ã© boa

3ï¸âƒ£ Crie uma TAG (o verdadeiro save point)

Agora vocÃª nomeia essa versÃ£o:

git tag -a v2025-01-27-html-ok -m "VersÃ£o estÃ¡vel com vento e rajada corretos no HTML"


ğŸ‘‰ Isso cria um marco imutÃ¡vel.

4ï¸âƒ£ Envie tudo para o GitHub (backup externo)
git push origin main
git push origin v2025-01-27-html-ok


ğŸ” Pronto:

EstÃ¡ salvo localmente

EstÃ¡ salvo no GitHub

Pode errar sem medo

COMO USAR ISSO COM O CODEX (fluxo correto)
Antes do Codex mexer
git checkout main
git pull


Confirme que estÃ¡ na versÃ£o certa:

git describe --tags







COMO RESTAURAR UMA VERSÃƒO ANTIGA (o mais importante)
ğŸ”™ Voltar para um save point
git checkout v2025-01-27-html-ok


ğŸ‘‰ O cÃ³digo volta exatamente para aquele estado.

Se quiser continuar a partir dali:

git checkout -b hotfix-a-partir-da-estavel

ğŸ§¯ EmergÃªncia: voltar a main para uma versÃ£o estÃ¡vel
git reset --hard v2025-01-27-html-ok
git push origin main --force


âš ï¸ SÃ³ faÃ§a isso se vocÃª for o Ãºnico desenvolvedor (parece ser o caso).

COMO FAZER ISSO PELO VS CODE (sem decorar comandos)
Criar tag pelo VS Code

Ctrl + Shift + P

Digite: Git: Create Tag

Nome: v2025-01-27-html-ok

Mensagem: versÃ£o estÃ¡vel etc.

Ver tags

Source Control â†’ â€¦ â†’ View â†’ Tags

PADRÃƒO DE NOMES (use sempre)

Tags

vYYYY-MM-DD-descricao-curta


Exemplos:

v2025-01-27-html-ok
v2025-01-28-alarmes-l234-estaveis
v2025-01-29-pre-exe-build


Commits

STABLE: descriÃ§Ã£o
CODEX: descriÃ§Ã£o
HOTFIX: descriÃ§Ã£o

Resumo final (guarde isso)

âœ”ï¸ Commit = foto
âœ”ï¸ Tag = nome da foto
âœ”ï¸ Nunca rodar Codex sem branch
âœ”ï¸ Sempre criar tag antes
âœ”ï¸ Smoke test simples > testes complexos
âœ”ï¸ VocÃª sempre tem como voltar

Se quiser, no prÃ³ximo passo eu posso te entregar:

um checklist de 30 segundos antes de rodar Codex

ou um template fixo de mensagens de commit/tag

ou um fluxo â€œprÃ©-executÃ¡velâ€ (antes de gerar o .exe)

VocÃª agora estÃ¡ trabalhando como engenharia de software de produÃ§Ã£o, nÃ£o mais â€œtentativa e erroâ€.











Perfeito ğŸ‘
Agora vamos direto ao ponto, do jeito mais seguro e repetÃ­vel possÃ­vel.

âœ… SituaÃ§Ã£o atual (confirmando)

VocÃª jÃ¡ fez o merge no GitHub (via botÃ£o ou CLI).

O branch main no GitHub jÃ¡ contÃ©m as mudanÃ§as.

Seu VS Code/local ainda estÃ¡ com a versÃ£o antiga.

ğŸ‘‰ O que falta Ã© sincronizar o main local com o main remoto.

âœ… Forma CORRETA e segura de puxar para o VS Code

No terminal do VS Code (ou PowerShell), dentro da pasta do projeto:

1ï¸âƒ£ Garanta que vocÃª estÃ¡ no main
git checkout main


VocÃª deve ver algo como:

Switched to branch 'main'
Your branch is behind 'origin/main' by X commits


ou

Your branch is up to date

2ï¸âƒ£ Puxe as mudanÃ§as do GitHub
git pull origin main


âœ”ï¸ Isso:

baixa o cÃ³digo novo

atualiza seus arquivos locais

nÃ£o perde nada

nÃ£o sobrescreve histÃ³rico

3ï¸âƒ£ Confirme que estÃ¡ tudo sincronizado
git status


Resultado esperado:

On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean


ğŸ‘‰ Pronto. O VS Code jÃ¡ estÃ¡ com o cÃ³digo novo.

ğŸ§  O que aconteceu â€œpor baixo dos panosâ€

Quando vocÃª apertou Merge no GitHub:

O main remoto mudou

Seu main local nÃ£o muda sozinho

git pull = git fetch + git merge

Agora os dois estÃ£o alinhados

ğŸš¨ E se der conflito?

No seu caso:

âŒ NÃ£o ocorre conflito

âŒ VocÃª nÃ£o estava editando os mesmos arquivos localmente

âœ”ï¸ O merge jÃ¡ foi resolvido no GitHub

EntÃ£o git pull Ã© 100% seguro aqui.

ğŸ§© Alternativa pelo VS Code (interface grÃ¡fica)

Se preferir sem terminal:

Abra o VS Code

VÃ¡ em Source Control (Ctrl+Shift+G)

Clique em â‹¯ (trÃªs pontos)

Clique em Pull

Mas recomendo decorar o comando, como vocÃª pediu.

ğŸ§± Comando Ãºnico (para decorar)

Sempre que fizer merge no GitHub:

git checkout main && git pull origin main


Esse Ã© o mantra.

ğŸ” Regra de ouro (grave isso)

Merge no GitHub â‰  cÃ³digo no seu PC

SÃ³ existe cÃ³digo atualizado localmente depois de git pull






